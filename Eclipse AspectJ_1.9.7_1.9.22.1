AspectJ 1.9.22.1
New features
AspectJ 1.9.22.1 has no new features, only bugfixes and improvements.

Improvements
- The pointcut parser now traverses type parameters in generic types, e.g. in MyType<A, B> it also traverses the previously ignored type parameters A and B, enabling future improvements like more exact type matching or checks for illegal primitive type parameters. See issue #221.
- Performance issue due to repeated attempts to find classes without FQN

Other changes and bug fixes
- AJC core dump when mixing type name wildcards with generics
- Potential ThreadLocalMap.Entry accumulation in JoinPointImpl
- WeavingAdaptor optimisations cause Equinox weaving problems

AspectJ 1.9.22
New features
AspectJ 1.9.22 supports Java 22, its final and preview features, such as:

- JEP 456: Unnamed Variables & Patterns
- JEP 459: String Templates (Second Preview)
- JEP 463: Implicitly Declared Classes and Instance Main Methods (Second Preview)
- JEP 447: Statements before super(…​) (Preview)
- The following Java 22 features are API or JVM only, therefore irrelevant for the compiler and should just work out of the box:
- JEP 423: Region Pinning for G1
- JEP 454: Foreign Function & Memory API
- JEP 458: Launch Multi-File Source-Code Programs
- JEP 462: Structured Concurrency (Second Preview)
- JEP 464: Scoped Values (Second Preview)
- JEP 457: Class-File API (Preview)
- JEP 461: Stream Gatherers (Preview)
- JEP 460: Vector API (Seventh Incubator)

Improvements
No major improvements

Other changes and bug fixes
No major bug fixes

AspectJ 1.9.21.2
New features
AspectJ 1.9.21.2 is a maintenance release with no new language features, but an important improvement and a bugfix, see below.

Improvements
- Previously, when targeting the same join point from multiple around advices in annotation-style @AspectJ syntax, there were limitations in functionality in concurrent (multi-threaded) situations, if the around advice code was not inlined. This was improved in AspectJ 1.9.9 (see also issue #128), but the improvement only applied to child threads directly created during aspect execution and would fail for pre-existing, long-lived threads, e.g. thread pools used by executor services. Furthermore, the improvement could lead to memory leaks, not cleaning up thread-local references to posssibly expensive objects. In such situations, users had to switch to native-syntax aspects which never had that problem to begin with due to their different internal structure.

- Now, issue #141 has been resolved, closing the gap and, as well as possible given their different internal structure, bringing @AspectJ aspects up to par with native-syntax aspects in concurrent situations, while simultaneously also addressing the memory leak issue #288. This is a substantial improvement, and annotation-style syntax users are strongly engouraged to upgrade. Thanks to user pagrawalgit for raising the memory leak issue and triggering me to think about the concurrency issue more broadly and finally solve both in one shot.

Other changes and bugfixes
- The fix for issue #277 in AspectJ 1.9.21.1 introduced a regression bug in the optional weaving cache now fixed in issue #285. Thanks to user Kimming Lau for raising and re-testing both issues.

AspectJ 1.9.21.1
New features
- AspectJ 1.9.21.1 is a maintenance release with no new language features, but important improvements and some bugfixes, see below.

Improvements
- For load-time weaving (LTW) on JDK 16+, using --add-opens is no longer necessary! This solves issue #117. The additional JVM command-line option was necessary for LTW on JRE 16+ in all AspectJ versions up to 1.9.21. Since AspectJ 1.9.21.1, the LTW agent uses an alternative approach for defining new classes during weaving, which works without --add-opens - at least for now, i.e. JDKs 8 to 21. There still is no canonical solution, because JDK-8200559 is still unresolved since 2018.
- The AspectJ documentation is now written in asciidoc format and processed by the Asciidoctor toolchain. Before, it was a mixture of DocBook XML and plain HTML files. While the content has not changed much, it now looks fresher, is easier to read (also online when browsing the GitHub repository), navigate and maintain and also easy to publish in different formats (multi-page HTML, single-page HTML, PDF). Those formats are also distributed on the website and with the AspectJ installer. A content overhaul is also overdue, but not part of this change. It is still basically the same: Everything up to AspectJ 1.5 is in the regular documentation. The changes since then can be extracted incrementally from various release notes.

Other changes and bugfixes
- Running the AspectJ Compiler on JDK < 17 no longer creates an ajcore.*.txt crash dump file, but prints "The AspectJ compiler needs at least Java runtime 17". Fixes issue #269.
- The AspectJ weaver now plays nicer with parallel class loaders, e.g. jboss-modules in WildFly. Before, it would sometimes return original instead of woven byte code. Fixes issue #279.
- An upstream refresh from JDT Core (Eclipse Java Compiler) fixes a little bug in JDK 21 string templates.

AspectJ 1.9.21
New features
- AspectJ 1.9.21 supports Java 21, its final features and a subset of preview features, such as:
- Record patterns
- Pattern matching for switch
- Virtual threads
- Sequenced collections
- Structured concurrency (preview)
- String templates (preview)
- Instance main methods (preview)
- Unfortunately, even after holding back the AspectJ release for 3 months after JDK 21 general availability, waiting for Eclipse JDT Core and the Eclipse Java Compiler (ECJ) to catch up with Java 21 language features, even with Java 21 officially supported in Eclipse 2023-12, some preview features are still unimplemented in ECJ:
	- Unnamed classes (preview)
	- Unnamed patterns and variables (preview)
As soon as these preview features are part of the upstream ECJ we depend on, we hope to publish another AspectJ release to support them in the AspectJ Compiler (AJC), too.

Improvements
- In GitHub issue 266, exception cause reporting has been improved in ExtensibleURLClassLoader. Thanks to Andy Russell (@euclio) for his contribution.

Other changes and bug fixes
No major bug fixes


AspectJ 1.9.20.1
This is a bugfix release for 1.9.20, fixing two problems:
- Regression bug 257 introduced in 1.9.20 would match negated type patterns like !void or !String[] incorrectly.

- Spring issue 27761 describes a problem where AspectJ, when used by Spring AOP, in rare cases falsely considered bridge methods for overridden generic methods for matching, leading to falsely negative matching results. See also AspectJ tracker issue 256).


AspectJ 1.9.20
New features
AspectJ 1.9.20 supports Java 20 and its final, preview and incubator features, such as:
- Record patterns (preview)
- Virtual threads (preview)
- Pattern matching for switch (preview 3)
- Structured concurrency (incubator)

Please note, that the upstream Eclipse Java Compiler (ECJ), which the AspectJ Compiler (AJC) is a fork of, still has some open issues concerning Java 20 preview feature support, see the list in this comment. AJC therefore inherits the same problems for the specific cases described in the linked issues.

Improvements
- Since Java 9 and the introduction of the Java Module System, the upstream Eclipse Java Compiler (ECJ) and Eclipse Java Development Tools (JDT) had gone through some internal changes, enabling both the compiler and the IDE to handle new Java language features. In AspectJ, some of those internal changes have not been properly upgraded for quite a while, but this is now fixed. However, it might require you to recompile your aspects and projects/classes using them. Otherwise, you might get problems in Eclipse IDE or under certain circumstances even when running newly compiled aspects in older AspectJ versions and vice versa. You are on the safe side if you simply rebuild your projects. We are sorry for the inconvenience, but we have to follow upstream ECJ and JDT changes.

- Along with fixing GitHub bug 24, the syntax for array type matching has been improved considerably. You can find some examples here.

Code examples
You can find some sample code in the AspectJ test suite under the respective AspectJ version in which the features were first supported (possibly as JVM preview features):
- Pattern matching for switch (preview 1)
- Pattern matching for switch (preview 2)
- Pattern matching for switch (preview 3), record patterns (preview 1)
- Pattern matching for switch (preview 4), record patterns (preview 2)
- Please note that presently there is no specific sample code for virtual threads and structured concurrency in the AspectJ code base, because these are just new APIs, no Java language features. You can find sample code for these concurrency features elsewhere, e.g. in the corresponding JEPs. In AspectJ, they should just work transparently like any other Java API.

Other changes and bug fixes
- About a dozen bugs have been fixed, some of them quite old. See "list of issues addressed" further above and follow the link to GitHub to find out if your issue is among them.

AspectJ 1.9.19
New features
AspectJ 1.9.19 supports Java 19 and its final, preview and incubator features, such as:
- Record patterns (preview)
- Virtual threads (preview)
- Pattern matching for switch (preview 3)
- Structured concurrency (incubator)

Please note that the upstream Eclipse Java Compiler (ECJ) which the AspectJ Compiler (AJC) is a fork of still has some open issues concerning Java 19 preview feature support, see the list in this comment. AJC therefore inherits the same problems for the specific cases described in the linked issues.

Improvements
- Improve condy (constant dynamic) support. Together with some custom compilation or weaving options, this helps to avoid a problem when using JaCoCo together with AspectJ, see this comment in #170 for more details.

Code examples
You can find some sample code in the AspectJ test suite under the respective AspectJ version in which the features were first supported (possibly as JVM preview features):
- Pattern matching for switch (preview 1)
- Pattern matching for switch (preview 2)
- Pattern matching for switch (preview 3), record patterns (preview 1)
- Please note that presently there is no specific sample code for virtual threads and structured concurrency in the AspectJ code base, because these are just new APIs, no Java language features. You can find sample code for these concurrency features elsewhere, e.g. in the corresponding JEPs. In AspectJ, they should just work transparently like any other Java API.

Other changes and bug fixes
- Fix (or rather work around) an old bug occurring when compiling or weaving code using ITD to declare annotations with SOURCE retention on types, methods, constructors or fields. While declaring such annotations does not make sense to begin with, at least the AspectJ weaver or compiler should handle the situation gracefully, which now it does by simply ignoring errors caused by it. See Bugzilla #366085 and pull request #196. Better than this workaround would be for the compiler or weaver to actually print a warning when meeting source level annotations in declare statements. Hence, follow-up issue #201 was created.
- Remove legacy AspectJ Browser code and documentation.
- Thanks to Andrey Turbanov for several clean code contributions.

AspectJ 1.9.9.1
- Bugfix release for some compiler options related to the Java Platform Module System (JPMS) which were not working, most importantly --add-modules, --add-exports and --add-reads. See issue #145.

- This probably was broken for a long time. AspectJ still is not boasting extensive JPMS support or test coverage, but this improvement seems substantial enough to justify a minor release, instead of keeping users waiting for the next regular release.

AspectJ 1.9.9
New features
AspectJ 1.9.9 supports Java 18 and its final and preview features, such as:
- Pattern matching for switch (preview 2)

Improvements
- In annotation style aspects, asynchronous proceed() calls in @Around advice now works in threads created from within the advice. Previously, this was only working in native syntax aspects. There is still a limitation with regard to asynchronous proceed, if you do not create the thread in the advice but want to use e.g. an ExecutorService with its own thread pool. This still is not working in annotation style aspects, only in native syntax ones.
- See issue #128 and pull request #132 for more details.

Code examples
You can find some sample code in the AspectJ test suite under the respective AspectJ version in which the features were first supported (possibly as JVM preview features):
- Pattern matching for switch, preview 1
- Pattern matching for switch, preview 2
- Asynchronous proceed in native vs. annotation style syntax

Other changes and bug fixes
- Fix a bug which led to NullPointerExceptions, if too many JAR archives were on the classpath. Too many here means the value of system property org.aspectj.weaver.openarchives (1,000 by default). The AspectJ compiler is meant to close archives upon cache exhaustion and then re-open them, if it needs them again later. Re-opening was broken, but now the compiler works reliably even for cache sizes as small as 20. See issue #125.
- Improvements for if() pointcuts in annotation syntax, see issues #115, #120, #122.
- Thanks to Andrey Turbanov for several clean code contributions.

AspectJ 1.9.8
New features
AspectJ 1.9.8 supports Java 17 and its final and review features, such as:
- Sealed classes (final in Java 17, previews in Java 15, 16 and AspectJ 1.9.7)
- Pattern matching for switch

Improvements
- The --release N compiler option for correct cross-compilation to previous JDK bytecode + API versions is now supported by AJC. Previously, the option existed (inherited by ECJ) but did not work correctly.
- The following new properties can improve performance, e.g. Spring start-up time:
	- org.aspectj.apache.bcel.useSingleRepositoryInstance
	- org.aspectj.apache.bcel.useUnavailableClassesCache
	- org.aspectj.apache.bcel.ignoreCacheClearRequests
- For now, they all default to false for backward compatibility. This might change in a future Aspect release, if user feedback is positive and no negative side effects are found. Please try using them as much as you can and report back questions (to the AspectJ users mailing list) or problems (as a GitHub issue), if any. Thanks to Stefan Starke for his contribution. See also PR #37.

Code examples
You can find some sample code in the AspectJ test suite under the respective AspectJ version in which the features were first supported (possibly as JVM preview features):
- Cross-compilation to legacy JDK: An example class which only works correctly on JDK 8 when compiled with --release 8 due to API changes in the JDK. Simply -source 8 -target 8 would not be enough in this case.
- Pattern matching for switch

Other changes and bug fixes
- The AspectJ compiler ajc (contained in the aspectjtools library) no longer works on JDKs 8 to 10. The minimum compile-time requirement is now JDK 11 due to upstream changes in the Eclipse Java Compiler (subset of JDT Core), which AspectJ is a fork of. You can still compile to legacy target versions as low as Java 1.3 when compiling plain Java code or using plain Java ITD constructs which do not require the AspectJ runtime aspectjrt, but the compiler itself needs JDK 11+. Just like in previous AspectJ versions, both the runtime aspectjrt and the load-time weaver aspectjweaver still only require JRE 8+.
- Document build profiles and properties in docs/developer/BUILD.md
- Add a guide for setting up an AspectJ development environment in docs/developer/IDE.md
- Fix issue #105: Compilation fails when using an aspect library via -aspectpath in combination with introducing an annotation via ITD. This was broken since version 1.9.5 and fixed in 1.9.8.RC3.
- Fix issue #68: Correctly process class files containing dynamic class-file constants (JEP 309), which were introduced in Java 11 and broken in AspectJ ever since their introduction in 1.9.2. Java itself currently does not use "condy" and neither do other widespread JVM languages. Byte code engineering libraries like ASM or Byte Buddy and some instrumentation tools like JaCoCo can however produce condy code. Therefore, in order to create a regression test, we actually had to craft a condy class with ASM.
- Thanks to Andrey Turbanov for several clean code contributions and to Dmitry Mikhaylov for fixing a potential concurrency problem.

AspectJ 1.9.7
New features
AspectJ 1.9.7 supports Java 15 & Java 16 and their respective final and review features:
- text blocks (final 15)
- records (preview 15, final 16)
- instanceof pattern matching (preview 15, final 16)
- hidden classes (final 15)
- sealed classes (preview 15, preview 16)
For features marked as preview on a given JDK, you need to compile with ajc --enable-preview and run with java --enable-preview on that JDK.

Please note, that you cannot run code compiled with preview features on any other JDK than the one used for compilation. For example, records compiled with preview on JDK 15 cannot be used on JDK 16 without recompilation. This is a JVM limitation unrelated to AspectJ. Also, e.g. sealed classes are preview-1 on JDK 15 and preview-2 on JDK 16. You still need to recompile, no matter what.

You can find some sample code in the AspectJ test suite under the respective AspectJ version in which the features were first supported (possibly as JVM preview features):
- AspectJ 1.9.5: text blocks
- AspectJ 1.9.6: records, instanceof patterns
- AspectJ 1.9.7: hidden classes, sealed classes

Using LTW on Java 16+
- Please note that if you want to use load-time weaving on Java 16+, the weaving agent collides with JEP 396 (Strongly Encapsulate JDK Internals by Default). Therefore, you need to set the JVM parameter --add-opens java.base/java.lang=ALL-UNNAMED in order to enable aspect weaving. This is due to the fact that the weaver uses internal APIs for which we have not found an adequate replacement yet when defining classes in different classloaders.

- Update: As of AspectJ 1.9.21.1, --add-opens is no longer necessary. Please upgrade, if it bothers you too much.

Organisational and internal changes
For AspectJ 1.9.7, we implemented a lot of internal changes concerning the build and release process, most of which are not visible in the product itself but will help us to more easily maintain and release the product in the future and more easily on-boarding new developers or contributors. For example:
- The main repository has been moved to GitHub, i.e. you can open bug reports, feature requests and pull requests there now.
- The Maven build has been improved, i.e. it is now easier to build and contribute to the product. Developers can just import the Maven project and no longer depend on Eclipse to build and test AspectJ, but can e.g. also use IntelliJ IDEA.
- Continuous integration builds now run on GitHub for different JDK versions, also for pull requests. I.e. both maintainers and contributors get to know if their changes break any tests.
- We can build releases and deploy them directly to Sonatype OSSRH (snapshots) or Maven Central (releases) with Maven now, i.e. it should be much easier in the future to publish development versions in order to enable users to re-test fixed bugs or try new features.
- All tests are portable now, i.e. they correctly run on Windows, too. This enables developers and contributors to make a choice if they want to work on Linux or on Windows.

Other changes and bug fixes
- Remove legacy JRockit support.
- Support Windows 10 and Windows Server 2016/2019 in installer. Those versions were not detected until now, which led to bogus Windows batch files forwarding only 9 AJC parameters to the Java process via %1 %2 %3
%4 %5 %6 %7 %8 %9 instead of %*.
- AJdoc (AspectJ’s javadoc generator add-on for aspects) now supports the JDK 16 javadoc generator.
- Fix serialVersionUID initialization for Java 9+
- AJC (AspectJ Compiler) usage texts sometimes used to be printed twice and they were printed too often, e.g. on top of every compile error. This has been fixed. Furthermore, the partly outdated usage text is now basically the same as ECJ (Eclipse Java Compiler), which AJC is a fork of, plus AspectJ-specific additions which are added during runtime.
- Source and javadoc JARs distributed together with the AspectJ artifacts on Maven Central are now more accurate and more complete with regard to what is included (ASM, JDT Core) and how package names have been relocated.
- Fix sample code formatting issues (indentation) throughout the documentation.






